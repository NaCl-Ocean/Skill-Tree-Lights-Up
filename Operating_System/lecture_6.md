<center><font face="黑体" color=black size=7>虚拟内存</font></center>

# 前引

- 为什么需要虚拟内存
  - 程序大小受到实际内存大小的限制
  - 内存容量限制并发的进程数量
- 之前介绍过解决上述问题的方法
  - 覆盖技术：需要用户程序支持
  - 交换技术：进程的挂起

# 虚拟内存

- **虚拟内存的思想**
  - 基于分页或分段以及局部性原理
  - 进程运行的过程中，主存中只存放几个块/帧/段，而进程的全部信息存放在辅存中
- **虚拟内存的流程**
  - 进程的常驻集存放主存中
  - 当访问不在主存的地址时，产生**缺块中断**
    1. OS发出I/O请求，进程阻塞，进行进程切换
    2. I/O请求结束，产生中断，阻塞的进程转为就绪态

- **虚拟内存的优点**
  - 可以有更多的进程驻存在主存中
  - 进程可以大于整个主存空间
- **虚拟内存的缺点**
  - 系统抖动（块的调入调出），处理器需要处理I/O操作

- 虚拟内存需要的硬件支撑
  - 是否采用虚拟存储技术
  - 是否使用分页、分段
  - 存储管理所使用的算法

# 虚拟内存需要的硬件支撑

- 分页

  - 每一个进程同样需要维护一个页表

    - ```
      # 页表
      页号：|主/辐标志 P|修改位 M|other control bits|Frame Number|
      P:表示该页是否在主存中有存储
      M:若标记修改，则在修改辅存中的该块对应的信息时，需要先从主存中将该块移到辅存中，若未标记修改，则不需要进行该I/O操作
      ```

    - 通过virtual address查找相应的块的流程：

      1. 通过virtual address的页号在页表中找到对应的项
      2. 如果P标志主，则直接根据Frame Number找到在主存中存放的帧，之后根据offset+帧的起始位置获得数据
      3. 如果P标志辅，那么发出I/O中断，将辅存中该页移入主存中，I/O中断完成后，再次根据Frame Number找到在主存中存放的帧，之后根据offset+帧的起始位置获得数据

  - 页表往往会很大，如何解决

    - 多级页表
    - 反向页表

  - **转移后备存储器（TLB）**  

    - 为什么需要
      - 虚拟内存访问需要两次访问内存：访问页表，访问数据
    - 是什么
      - 将页表移入高速缓存，减少访问内存的次数
      - 移入最近使用过的页表

  - 页越小

    - 页内碎片总量越小
    - 每个进程的页表越大
    - I/O效率低（一小块一小块地搬和一大块一大块地搬相比）

  - 