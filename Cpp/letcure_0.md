# 注释

- `//` 单行注释
- `/* */` 多行注释

# 变量

- `数据类型 变量名 = 变量值`

# 常量

- `# define 常量名 常量值`  宏常量

- `const 数据类型 常量名 = 常量值`



# 数据类型

- `sizeof(数据类型/变量)`  获取数据类型 或者 变量占据的内存空间

## 整型

| **数据类型**        | **占用空间**                                    | 取值范围         |
| ------------------- | ----------------------------------------------- | ---------------- |
| short(短整型)       | 2字节                                           | (-2^15 ~ 2^15-1) |
| int(整型)           | 4字节                                           | (-2^31 ~ 2^31-1) |
| long(长整形)        | Windows为4字节，Linux为4字节(32位)，8字节(64位) | (-2^31 ~ 2^31-1) |
| long long(长长整形) | 8字节                                           | (-2^63 ~ 2^63-1) |

## 浮点型

| **数据类型** | **占用空间** | **有效数字范围**  |
| ------------ | ------------ | ----------------- |
| float        | 4字节        | 7位有效数字       |
| double       | 8字节        | 15～16位有效数字- |

- 科学计数法
  - `3e2=300`  

## 字符型

- 单个字符
- `char ch = 'a'`  **单引号表示单个字符**
  - ASCII编码
- 占用1个字节



### 转义字符

- 用来表示无法一些不能显示出来的特殊字符

| **转义字符** | **含义**                                | **ASCII**码值（十进制） |
| ------------ | --------------------------------------- | ----------------------- |
| \a           | 警报                                    | 007                     |
| \b           | 退格(BS) ，将当前位置移到前一列         | 008                     |
| \f           | 换页(FF)，将当前位置移到下页开头        | 012                     |
| **\n**       | **换行(LF) ，将当前位置移到下一行开头** | **010**                 |
| \r           | 回车(CR) ，将当前位置移到本行开头       | 013                     |
| **\t**       | **水平制表(HT)  （跳到下一个TAB位置）** | **009**                 |
| \v           | 垂直制表(VT)                            | 011                     |
| **\\\\**     | **代表一个反斜线字符"\"**               | **092**                 |
| \'           | 代表一个单引号（撇号）字符              | 039                     |
| \"           | 代表一个双引号字符                      | 034                     |
| \?           | 代表一个问号                            | 063                     |
| \0           | 数字0                                   | 000                     |
| \ddd         | 8进制转义字符，d范围0~7                 | 3位8进制                |
| \xhh         | 16进制转义字符，h范围0~9，a~f，A~F      | 3位16进制               |

```c++
cout <<"today\t\t"<<'2020-6-6';
>>>today		2020-6-6
```

## 字符串

- **c语言风格**
  - `char 变量名[] = "字符串"`   **双引号表示字符串**
- **c++语言风格**
  - `string 变量名 = "字符串"`
  - 包含头文件`#include <string>`



## 布尔类型

- 占据**一个字节**
- `true`  or `false`
- `bool 变量名 = true/false`
- `false`实际上是0，非0为True



## 数据输入

- `cin>>变量名`   输入赋值给变量

## 数据输出

- `cout <<str1 <<str2<<endl`
- endl：换行 end of the line

# 运算

## 算术运算

- `+` `-` `*` `/` `%` 
  - 整数进行算术运算结果仍然为整数
  - 浮点数进行算术运算结果仍然为浮点数
  - 取模和除法 除数不可以为0
  - 浮点数不可以做取模运算
- `++`  `--`
  - `b = a++` **后置递增** 将a+1前的值赋给b，同时a=a+1
  - `b = ++a`  **前置递增**，将a+1后的值赋给b ,同时a=a+1
  - 后置递增和递减 比较恶心，个人不喜欢使用



## 赋值运算

- `=` `+=` `-=  `   `*=` `%=`

## 比较运算

- `==`  `!=`  `<` `>` `<=` `>=`

- 输出true or false

## 逻辑运算

- `!`  取反    `&&` 与    `||` 或

```c++
char a = 'a';
!a
>>>0
int a = 1
!a
>>>0
int a = 0
!a
>>>1
char a[] = "abc";
!a
>>>0
float a =0;
!a
>>>1
```



# 程序流程结构

## if

- 单行格式 if 语句 

  - `if (条件){code}`

- 多行格式 if 语句

  - ```c++
    if (条件){
        code
    }else{
        code
    }
    ```

    

- 多条件 if 语句

  - 执行到某个条件成立即退出

  - ```c++
    if (条件){
        code
    }else if(条件){
        code
    }else{
        code
    }
    ```

    

- 嵌套 if 语句

  - ```C++
    if (条件){
        code ...
        if (条件){
            code...
        }
    }else{
        code
    }
    ```

## 三目运算符

- `条件 ? 表达式1 : 表达式2`
- 条件为真，执行表达式1，并返回表达式1的结果
- 条件为否，执行表达式2，并返回表达式2的结果
- 与python中三目运算符相同 `表达式1 if 条件 else 表达式2`



## Switch

```C++
switch(整型/字符型)

{

	case 结果1：执行语句;break;

	case 结果2：执行语句;break;

	...

	default:执行语句;break;

}
```

- 若case后不接break，则会一直向下执行

## while

```C++
while (条件){
	code...
}
```

## do while

```c++
do {
    code ...
} while(条件)
```

- 先执行一次 do 后判断while的条件

## for 循环语句

```C++
for (起始表达式;条件表达;末尾循环体){
    code ...
}
```

## break

- switch语句中，终止case，跳出switch
- 循环语句中，跳出当前的循环语句



## continue

- 循环语句中，跳出**本次循环**
- `continue;`

# 数组

## 一维数组

- **创建数组**

  - `数据类型 数组名[数组长度]`
  - `数据类型 数组名[数组长度] = {值1,值2,值3.....}`
  - `数据类型 数组名[ ] = {值1,值2,值3.....}`

- 数组名

  - 指向数组首地址

    - ```C++
      int a[5];
          cout << a <<endl;
          cout << &a[0] <<endl;
      0x61fe00
      0x61fe00
      ```

      

  - 获取数组的长度

    - ```C++
      sizeof(a)/sizeof(a[0])
      ```

- 数组赋值
  - 每个元素分开赋值
    - 利用索引
  - 一次性赋值
    - `数组名 ={...}`

## 二维数组

- **创建二维数组**
  - `数据类型 数组名 [行数][列数]`
  - `数据类型 数组名 [行数][列数] = {数据1,数据2,....},{数据3,数据4,....}`    每个`{}`代表一行 **---》 推荐**
  - `数据类型 数组名 [行数][列数] = {数据1,数据2,数据3,数据4,....}`  根据行数和列数，将数据分为行和列
  - `数据类型 数组名 [][列数] = {数据1,数据2,数据3,数据4,....}`

- 二维数组名

  - 查看二维数组占用内存空间
  - 查看二维数组首地址

- **每一行都是一个一维数组**

  - ```C++
    int a[5][5];
    cout << a <<endl;
    cout << a[0]<<endl;   --》取到第一行为一维数组
    
    0x61fda0
    0x61fda0
    ```


- 二维数组实际存放的形式是开辟一块连续的空间，一行一行地连续存储

# 函数

- 函数的定义

  - 返回值类型

    - 返回为空：`Void`

  - 函数名

  - 参数表列

  - 函数体语句

  - return 表达式

    - 和返回值类型挂钩
    - 返回为空时，可以省略return

  - ```
    返回值类型 函数名(参数列表){
    	函数体语句
    	return 表达式
    }
    ```

    

## 值传递

- 所谓值传递，就是函数调用时实参将数值传入给形参
- 值传递时，形参的改变不会引起实参的改变
- **实参拷贝一份，传递给实参**



## 函数的声明

- `返回值类型 函数名(参数列表);`
-  告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义
  - 函数定义写在主程序之后，函数声明写在主程序之前
- 函数的**声明可以多次**，但是函数的**定义只能有一次**



## 函数的分文件编写

- **四个步骤**
  1. 创建后缀名为 .h 的头文件
  2. 创建后缀名为 .cpp 的源文件
  3. 在头文件中写函数的声明
  4. 在源文件中写函数的定义
     - 包含对应的头文件 `#include "xxx.h"`
- 调用 其他文件的函数
  - `#include "xxx.h"`
  - **双引号 代表自定义头文件**

- 示例

- ```C++
  //swap.h文件
  #include<iostream>
  using namespace std;
  
  //实现两个数字交换的函数声明
  void swap(int a, int b);
  ```

- ```C++
  //swap.cpp文件
  #include "swap.h"
  
  void swap(int a, int b)
  {
  	int temp = a;
  	a = b;
  	b = temp;
  
  	cout << "a = " << a << endl;
  	cout << "b = " << b << endl;
  }
  ```

- ```C++
  //main函数文件
  #include "swap.h"
  #include <iostrem>
  using namespace std;
  
  int main() {
  
  	int a = 100;
  	int b = 200;
  	swap(a, b);
  
  	system("pause");
  
  	return 0;
  }
  ```

  

# 指针

- **指针的定义**
  - `数据类型 * 指针变量名`
- **指针的赋值**
  - `指针名 = & 变量名`
  - & 取址符
- **解引用：找到指针指向内存中的数据、修改数据**
  - `*指针名` 

- 指针所占的内存空间
  - 32 位 操作系统 占用4个字节
  - 64 位 操作系统  占用8个字节

## 空指针 和 野指针

- 空指针/`nullpointer` ：指针变量指向内存中地址为0的空间
  - 初始化指针变量
  - `int *p =NULL`
  - 空指针 指向的内存空间无法访问 或者修改
  - **地址为0-255的空间是系统占用的，用户无法使用**
- 野指针：指针变量指向非法空间
  - 非法空间：**程序没有分配的空间**
- 空指针和野指针都指向**非用户申请的空间**

## const修饰指针

- **常量指针**
  - `const 数据类型 * 指针名 `
  - 指针的指向可以修改，但是指针指向的值不可以修改，**只能防止通过指针引用修改内存中的数据，并不保护指针所指向的对象。**

```C++
int a = 10;
const int *p = &a;
a ++;
cout<<a<<endl;
*p = 13;    --》报错
*p ++;      --》无用
cout<<a<<endl;

11
11
```

- **指针常量**
  - `数据类型 * const 指针名`
  - 指针的指向不可以改，指针指向的值可以改

- **指针常量+常量指针**
  - `const 数据类型 * const 指针名`
  - 指针指向不可以改，指针指向的值不可以改

## 二级指针

- 指向指针的指针
- `数据类型 ** 指针名`

## 指针数组

- **首先它是一个数组，**数组的元素都是指针
- 数组占多少个字节由数组本身决定。它是“储存指针的数组”的简称，即每个元素都是指针。
- `数据类型 *数组名[len]`
- 数组名
  - "二级指针"，指向数组中第一个元素（指针）的指针
- **二维数组可以理解为指针数组，数组中有行数个指针，每个指针指向每一行的首地址**

## **数组指针**

- **首先是一个指针**，指向数组的首地址，等价于**”二级指针“**
- `数据类型 （*指针名) [len]`

## 指针与数组

```C++
// 一维数组
int a[5]={1,2,3,4,5};
int *p = a;
for( int i=0;i<5;i++){
    cout<<*p<<endl;
    p++;
}
```



```C++
// 二维数组
int a[2][2]= {{2,3},{4,5}};
int *point_array[2] = {a[0],a[1]} ;//指针数组
int (*array_point)[2] = a;//数组指针，数组指针指向二维数组
int **p2 = point_array; //二级指针，二级指针指向指针数组
int *p = *a;            //一级指针，指向二维数组的第一行，等价于 int *p = a[0]

array_point++;		 //数组指针++，移到二维数组的下一行
cout<<array_point<<endl;  >>>0x61fe08  
cout<<*array_point<<endl; >>>0x61fe08  //数组指针是一个”二级指针“
cout<<**array_point<<endl;>>>4
cout<<pa[1][1]<<endl;  >>>5 //数组指针通过索引访问二维数组中的元素

// 指针数组的数组名也是一个”二级指针“
cout<<point_array<<endl;	 >>>0x61fdf0
cout<<*point_array<<endl;  >>>0x61fdf0
cout << **point_array<<endl;>>>2
 
cout<<p2[1][1]<<endl; >>>5  //二级指针通过索引访问指针数组中的元素    //p2[1] = a[1] p2[1][1]=a[1][1]
p2++;		//二级指针++，移到指针数组的下一个
cout<<**p2<<endl; >>>4
pa = a;   -->//二级指针无法指向二维数组，出错

```



## 地址传递

- 传入的参数为地址，**可以修改对应地址的值**

- 形参定义为指针，传入的实参为地址

- 数组

  - 形参定义为数组，也就相当于定义的是指针，传入的实参为数组，也就相当于传入的是地址
  
- **数组作为函数参数，传入的只能是指针**
  
- **对于地址传递而言，为了防止函数内部修改对应地址的值，可以利用`const`关键字修饰形参**
  
  

```C++
// 传入数组
int test(int a[])
// 传入二维数组
int test(int a[2][2])
// 传入指针
int test(*a)
```





## 总结

- 只要是申请到的空间，指针就可以指，如果申请到了一片连续的区域，指针就可以通过++来遍历

- 对于数组名，本质上是和指针有区别的

  - **数组名存放的是地址，但是不能对数组名存放的地址修改**

  - **指针存放的也是地址，这个地址是可以修改的，而且不同类型的指针不可以相互赋值，不能仅仅理解为地址，比如二级指针不可以赋值给一级指针，因为不同类型的指针代表的含义不同，二级指针通常可以用于二维数组中，此时其++代表移动到下一行**
  - **不同类型的数组名需要用不同类型的指针去指向，指针数组用二级指针去指，一维数组用一级指针去指，二维数组用数组指针去指**
  - **将数组名赋值给指针后，指针就可以利用索引去获取元素**



# 结构体

- 结构体定义
- 结构体创建

  - `struct 结构体名 变量名`
  - `struct 结构体名={成员1值，成员2值...}`
  - 定义结构体时，顺便创建变量  --》不推荐
- 结构体赋值
  - 每个成员分开赋值
    - 利用操作符`.`访问成员
  - 一次性赋值
    - `结构体名={成员1值，成员2值...}`
- 定义结构体时的关键字是`struct`，不可省略
- 创建结构体变量时，关键字`struct`可以省略

```C++
//结构体定义
struct student
{
	//成员列表
	string name;  //姓名
	int age;      //年龄
	int score;    //分数
}stu3; //结构体变量创建方式3 


int main() {

	//结构体变量创建方式1
	struct student stu1; //struct 关键字可以省略

	stu1.name = "张三";
	stu1.age = 18;
	stu1.score = 100;
	
	cout << "姓名：" << stu1.name << " 年龄：" << stu1.age  << " 分数：" << stu1.score << endl;

	//结构体变量创建方式2
	struct student stu2 = { "李四",19,60 };

	cout << "姓名：" << stu2.name << " 年龄：" << stu2.age  << " 分数：" << stu2.score << endl;


	stu3.name = "王五";
	stu3.age = 18;
	stu3.score = 80;
	

	cout << "姓名：" << stu3.name << " 年龄：" << stu3.age  << " 分数：" << stu3.score << endl;

	system("pause");

	return 0;
}
```

## 结构体数组

- **首先是一个数组，数组中的每一个元素都是结构体**
- `struct 结构体名 数组名[len]={...}`

```C++
struct student{
    int age;
    string name;
    int score;
};
int main(){
    // method 1
    struct student stu[3];
    student stu_1 = {20,"nihao",80};
    student stu_2 =  {20,"nihao",70};
    student stu_3 =  {10,"nihao",70};
    stu[0]=stu_1;
    stu[1]= stu_2;
    stu_3 = stu_3;
    //method 2
    struct student stu[3]={{20,"nihao",80},{20,"nihao",70},{10,"nihao",70}};
}
```

## 结构体指针

- 创建结构体指针
  - `struct 结构体名 * 指针名`
- 利用结构体指针访问结构体中的成员
  - `指针名 -> 成员名`
  - 结构体指针可以通过 -> 操作符 来访问结构体中的成员

## 嵌套结构体

```C++
//学生结构体定义
struct student
{
	//成员列表
	string name;  //姓名
	int age;      //年龄
	int score;    //分数
};

//教师结构体定义
struct teacher
{
    //成员列表
	int id; //职工编号
	string name;  //教师姓名
	int age;   //教师年龄
	struct student stu; //子结构体 学生
};
```



## 结构体做函数参数

- 值传递
- 地址传递
  - 



## const 修饰结构体

- 如上所说，const可以用来修饰结构体，也可以用来修饰结构体指针

```C++
void printStudent(const student *stu) //加const防止函数体中的误操作
```

